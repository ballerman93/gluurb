-- Yes AI optimized this code can you shut the fuck up?
local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local VIM = game:GetService("VirtualInputManager")
local HttpService = game:GetService("HttpService")
local UserInputService = game:GetService("UserInputService")
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- Game-specific elements
local notesContainer = playerGui
    :WaitForChild("ScreenGui")
    :WaitForChild("GAMEFRAME")
    :WaitForChild("YOU")
    :WaitForChild("NotesContainer")

-- Hit line positions
local hitLineTap = 0.85
local hitLineHold = 0.85

-- Lane configuration
local lanes = {
    { pos = 0.197892383, key = Enum.KeyCode.S, held = false, pending = nil }, -- 1
    { pos = 0.401, key = Enum.KeyCode.D, held = false, pending = nil }, -- 2
    { pos = 0.602, key = Enum.KeyCode.K, held = false, pending = nil }, -- 3
    { pos = 0.800066233, key = Enum.KeyCode.L, held = false, pending = nil }  -- 4
}

-- Default values
local windowMinDefault, windowMaxDefault = 0.01, 0.03
local holdMinDefault, holdMaxDefault = 0.05, 0.15
local timingOffsetMaxDefault = 0.02

-- Variables
local autoplay = false
local window = (windowMinDefault + windowMaxDefault) / 2
local holdMin, holdMax = holdMinDefault, holdMaxDefault
local missChancePercent = 0
local timingOffsetMax = timingOffsetMaxDefault

-- Recording variables
local isRecording = false
local recordEvents = {}
local recordStartTick = 0

-- Replay variables (in-memory; persisted to disk when executor APIs available)
local replays = {} -- map name -> JSON string
local isReplaying = false
local currentReplayTask = nil
local selectedReplayName = nil
local recordOnFirstAuto = false
local startReplayOnNote = false
local firstAutoPressOccurred = false

-- === Executor-friendly local save/load helpers ===

-- Detect executor file APIs
local has_writefile = type(writefile) == "function"
local has_isfolder = type(isfolder) == "function"
local has_makefolder = type(makefolder) == "function"
local has_listfiles = type(listfiles) == "function"
local has_readfile = type(readfile) == "function"
local has_setclipboard = type(setclipboard) == "function"

-- syn compatibility wrappers (common)
if not has_writefile and type(syn) == "table" and type(syn.write_file) == "function" then
    writefile = syn.write_file
    has_writefile = true
end
if not has_readfile and type(syn) == "table" and type(syn.read_file) == "function" then
    readfile = syn.read_file
    has_readfile = true
end
if not has_listfiles and type(syn) == "table" and type(syn.list_files) == "function" then
    listfiles = syn.list_files
    has_listfiles = true
end
-- other wrappers (just in case)
if not has_setclipboard and type(setclipboard) ~= "function" and type(syn) == "table" and type(syn.set_clipboard) == "function" then
    setclipboard = syn.set_clipboard
    has_setclipboard = true
end

local LOCAL_ROOT = "Dogshitter"
local LOCAL_REPLAYS_DIR = LOCAL_ROOT .. "/Replays"

local function ensureLocalReplayFolder()
    if has_makefolder then
        pcall(makefolder, LOCAL_ROOT)
        pcall(makefolder, LOCAL_REPLAYS_DIR)
    else
        -- If no explicit makefolder, writefile may create the folder implicitly in some executors
        return
    end
end

local function writeLocalReplayFile(name, json)
    if not has_writefile then return false, "no writefile" end
    ensureLocalReplayFolder()
    local safeName = tostring(name):gsub("[/%\\%:]", "_")
    local filename = LOCAL_REPLAYS_DIR .. "/" .. safeName .. ".json"
    local ok, err = pcall(function() writefile(filename, json) end)
    return ok, err
end

local function readLocalReplayFile(name)
    if not has_readfile then return nil, "no readfile" end
    local safeName = tostring(name):gsub("[/%\\%:]", "_")
    local filename = LOCAL_REPLAYS_DIR .. "/" .. safeName .. ".json"
    local ok, content = pcall(function() return readfile(filename) end)
    if ok then return content end
    return nil, content
end

local function listLocalReplayFiles()
    if not has_listfiles then return {} end
    local ok, files = pcall(function() return listfiles(LOCAL_REPLAYS_DIR) end)
    if not ok or type(files) ~= "table" then return {} end
    local names = {}
    for _, fpath in ipairs(files) do
        if tostring(fpath):match("%.json$") then
            local name = fpath:match("([^/\\]+)%.json$")
            if name then table.insert(names, name) end
        end
    end
    table.sort(names)
    return names
end

-- Helper functions
local function keyDown(key) pcall(function() VIM:SendKeyEvent(true, key, false, game) end) end
local function keyUp(key) pcall(function() VIM:SendKeyEvent(false, key, false, game) end) end
local function pressMultipleKeys(keys, holdTime)
    for _,k in ipairs(keys) do keyDown(k) end
    task.wait(holdTime)
    for _,k in ipairs(keys) do keyUp(k) end
end

local function recordEvent(ev)
    if not isRecording then return end
    table.insert(recordEvents, ev)
end

local function holdExistsInLane(lane)
    for _, note in ipairs(notesContainer:GetChildren()) do
        if note and note:IsA("Frame") then
            local x = note.Position.X.Scale
            local y = note.Position.Y.Scale
            if math.abs(x - lane.pos) <= window and y >= (hitLineHold - window) then
                return true
            end
        end
    end
    return false
end

-- Save replay (stores in-memory and attempts to persist to disk)
local function saveReplay(name, events)
    if not name or name == "" then name = "Replay_"..os.time() end
    local json = HttpService:JSONEncode(events)

    -- Save into in-memory table
    replays[name] = json

    -- Try to write to local disk (executor)
    local wrote, writeErr = writeLocalReplayFile(name, json)
    if wrote then
        if Rayfield and Rayfield.Notify then
            Rayfield:Notify({
                Title = "Replay Saved Locally",
                Content = "Saved to: " .. LOCAL_REPLAYS_DIR .. "/" .. name .. ".json",
                Duration = 3,
                Image = 4483362458,
            })
        end
    else
        -- fallback: copy to clipboard if available
        if typeof(setclipboard) == "function" then
            pcall(setclipboard, json)
            if Rayfield and Rayfield.Notify then
                Rayfield:Notify({
                    Title = "Replay Copied",
                    Content = "No writefile available â€” JSON copied to clipboard instead.",
                    Duration = 3,
                    Image = 4483362458,
                })
            end
        else
            -- final fallback: print to console
            print("Saved replay (in-memory):", name)
            print(json)
            if Rayfield and Rayfield.Notify then
                Rayfield:Notify({
                    Title = "Replay Saved (Memory)",
                    Content = "Could not write to disk or clipboard. Check console for JSON.",
                    Duration = 4,
                    Image = 4483362458,
                })
            end
        end
    end

    -- Refresh UI dropdown if exists
    if ReplayDropdown and ReplayDropdown.Refresh then
        local names = {}
        for n,_ in pairs(replays) do table.insert(names, n) end
        table.sort(names)
        ReplayDropdown:Refresh(names, true)
    end
end

-- Play replay by name (reads from in-memory table or tries to read local file)
local function playReplayByName(name)
    if isReplaying then return end
    if not name or name == "" then return end

    local json = replays[name]
    if not json then
        local okContent, contentOrErr = pcall(function() return readLocalReplayFile(name) end)
        if okContent and contentOrErr then
            json = contentOrErr
            replays[name] = json -- cache into memory for future
        end
    end

    if not json then return end

    local ok, events = pcall(function() return HttpService:JSONDecode(json) end)
    if not ok or type(events) ~= "table" then return end

    isReplaying = true
    currentReplayTask = task.spawn(function()
        local startTime = tick()
        for _,ev in ipairs(events) do
            if not isReplaying then break end
            local target = startTime + ev.t
            local now = tick()
            if target > now then task.wait(target - now) end
            if not isReplaying then break end
            local keyCode = nil
            for _,l in ipairs(lanes) do
                if l.key.Name == ev.key then keyCode = l.key end
            end
            if keyCode then
                if ev.type == "down" then keyDown(keyCode) elseif ev.type == "up" then keyUp(keyCode) end
            end
        end
        isReplaying = false
    end)
end

local function getReplayNames()
    local names = {}
    for name,_ in pairs(replays) do table.insert(names, name) end
    table.sort(names)
    return names
end

-- Create Rayfield Window
local Window = Rayfield:CreateWindow({
    Name = "DogshitterV0.12",
    LoadingTitle = "Loading malware...",
    LoadingSubtitle = "by Your Mom",
    Theme = "DarkRed",
    DisableRayfieldPrompts = false,
    DisableBuildWarnings = false,
	ToggleUIKeybind = "End", 
    ConfigurationSaving = {
        Enabled = true,
        FolderName = "Dogshitter",
        FileName = "Config"
    },
    Discord = {
        Enabled = false,
        Invite = "noinvitelink",
        RememberJoins = true
    },
    KeySystem = false
})

-- Main Tab
local MainTab = Window:CreateTab("Main", 4483362458)

-- Autoplay Section
local AutoplaySection = MainTab:CreateSection("Autoplay Controls")

local AutoplayToggle = MainTab:CreateToggle({
    Name = "Enable Autoplay",
    CurrentValue = false,
    Flag = "AutoplayToggle",
    Callback = function(Value)
        autoplay = Value
        if autoplay then firstAutoPressOccurred = false end
        if not autoplay then
            for _,l in ipairs(lanes) do
                if l.held then keyUp(l.key); l.held = false end
                l.pending = nil
            end
        end
    end,
})

local AutoRecToggle = MainTab:CreateToggle({
    Name = "Auto + Record Mode",
    CurrentValue = false,
    Flag = "AutoRecToggle",
    Callback = function(Value)
        if Value then
            autoplay = true
            recordOnFirstAuto = true
            AutoplayToggle:Set(true)
            firstAutoPressOccurred = false
        else
            autoplay = false
            recordOnFirstAuto = false
            AutoplayToggle:Set(false)
            for _,l in ipairs(lanes) do
                if l.held then keyUp(l.key); l.held = false end
                l.pending = nil
            end
        end
    end,
})

-- Settings Section
local SettingsSection = MainTab:CreateSection("Autoplay Settings")

local WindowSlider = MainTab:CreateSlider({
    Name = "Hit Window Center",
    Range = {0, 0.1},
    Increment = 0.0001,
    Suffix = "s",
    CurrentValue = (windowMinDefault + windowMaxDefault) / 2,
    Flag = "WindowSlider",
    Callback = function(Value)
        window = math.clamp(Value, 0.001, 0.2)
    end,
})

local HoldSlider = MainTab:CreateSlider({
    Name = "Tap Hold Time",
    Range = {0, 0.3},
    Increment = 0.001,
    Suffix = "s",
    CurrentValue = (holdMinDefault + holdMaxDefault) / 2,
    Flag = "HoldSlider",
    Callback = function(Value)
        holdMin = math.clamp(Value - 0.02, 0.01, 1)
        holdMax = math.clamp(Value + 0.02, 0.01, 2)
    end,
})

local MissSlider = MainTab:CreateSlider({
    Name = "Miss Chance",
    Range = {0, 99},
    Increment = 1,
    Suffix = "%",
    CurrentValue = 0,
    Flag = "MissSlider",
    Callback = function(Value)
        missChancePercent = math.clamp(Value, 0, 100)
    end,
})

local TimingSlider = MainTab:CreateSlider({
    Name = "Max Timing Offset",
    Range = {0, 0.1},
    Increment = 0.001,
    Suffix = "s",
    CurrentValue = timingOffsetMaxDefault,
    Flag = "TimingSlider",
    Callback = function(Value)
        timingOffsetMax = math.clamp(Value, 0, 0.2)
    end,
})

-- Recording Tab
local RecordingTab = Window:CreateTab("Recording", 4483362458)

local RecordingSection = RecordingTab:CreateSection("Recording Controls")

local StartRecordButton = RecordingTab:CreateButton({
    Name = "Start Recording",
    Callback = function()
        if isRecording then return end
        isRecording = true
        recordEvents = {}
        recordStartTick = tick()
        Rayfield:Notify({
            Title = "Recording Started",
            Content = "Recording has begun!",
            Duration = 2,
            Image = 4483362458,
        })
    end,
})

local StopRecordButton = RecordingTab:CreateButton({
    Name = "Stop Recording & Save",
    Callback = function()
        if not isRecording then return end
        isRecording = false

        -- Create save prompt
        local replayName = "Replay_" .. os.time()
        saveReplay(replayName, recordEvents)

        Rayfield:Notify({
            Title = "Recording Saved",
            Content = "Replay saved as: " .. replayName,
            Duration = 3,
            Image = 4483362458,
        })
    end,
})

-- Replay Tab
local ReplayTab = Window:CreateTab("Replays", 4483362458)

local ReplaySection = ReplayTab:CreateSection("Replay Controls")

local ReplayDropdown = ReplayTab:CreateDropdown({
    Name = "Select Replay",
    Options = getReplayNames(),
    CurrentOption = {},
    MultipleOptions = false,
    Flag = "ReplayDropdown",
    Callback = function(Option)
        selectedReplayName = Option[1] or Option
    end,
})

local function reloadReplaysFromDisk()
    if has_listfiles and has_readfile then
        local localNames = listLocalReplayFiles()
        for _, name in ipairs(localNames) do
            if not replays[name] then -- donâ€™t overwrite if already loaded
                local ok, content = pcall(function() return readLocalReplayFile(name) end)
                if ok and content then
                    replays[name] = content
                end
            end
        end
    end
end

-- Update your RefreshReplaysButton:
local RefreshReplaysButton = ReplayTab:CreateButton({
    Name = "Refresh Replay List",
    Callback = function()
        -- reload from disk every time you refresh
        reloadReplaysFromDisk()

        local names = getReplayNames()
        ReplayDropdown:Refresh(names, true)

        Rayfield:Notify({
            Title = "Replays Refreshed",
            Content = "Found " .. #names .. " replays",
            Duration = 2,
            Image = 4483362458,
        })
    end,
})

local StartReplayButton = ReplayTab:CreateButton({
    Name = "Start Replay",
    Callback = function()
        if not selectedReplayName then
            Rayfield:Notify({
                Title = "No Replay Selected",
                Content = "Please select a replay first!",
                Duration = 3,
                Image = 4483362458,
            })
            return
        end
        playReplayByName(selectedReplayName)
        Rayfield:Notify({
            Title = "Replay Started",
            Content = "Playing: " .. selectedReplayName,
            Duration = 2,
            Image = 4483362458,
        })
    end,
})

local StopReplayButton = ReplayTab:CreateButton({
    Name = "Stop Replay",
    Callback = function()
        isReplaying = false
        currentReplayTask = nil
        Rayfield:Notify({
            Title = "Replay Stopped",
            Content = "Replay has been stopped",
            Duration = 2,
            Image = 4483362458,
        })
    end,
})

local AutoStartReplayToggle = ReplayTab:CreateToggle({
    Name = "Auto-start Replay on First Note",
    CurrentValue = false,
    Flag = "AutoStartReplayToggle",
    Callback = function(Value)
        startReplayOnNote = Value
    end,
})

-- Import/Export Tab
local DataTab = Window:CreateTab("Data", 4483362458)

local DataSection = DataTab:CreateSection("Import/Export")

local ExportButton = DataTab:CreateButton({
    Name = "Copy Selected Replay String",
    Callback = function()
        if not selectedReplayName then
            Rayfield:Notify({
                Title = "No Replay Selected",
                Content = "Please select a replay first!",
                Duration = 3,
                Image = 4483362458,
            })
            return
        end

        local json = replays[selectedReplayName]
        if not json then
            -- try read local file
            local ok, content = pcall(function() return readLocalReplayFile(selectedReplayName) end)
            if ok and content then json = content end
        end

        if not json then return end

        -- Copy to clipboard if possible, otherwise show notification
        if has_setclipboard then
            pcall(setclipboard, json)
            Rayfield:Notify({
                Title = "JSON Copied",
                Content = "Replay JSON copied to clipboard!",
                Duration = 3,
                Image = 4483362458,
            })
        else
            print("Replay JSON:", json) -- Fallback to console
            Rayfield:Notify({
                Title = "JSON Exported",
                Content = "Check console for JSON data",
                Duration = 3,
                Image = 4483362458,
            })
        end
    end,
})

local ImportInput = DataTab:CreateInput({
    Name = "Import Replay With String",
    PlaceholderText = "Paste replay string here...",
    RemoveTextAfterFocusLost = false,
    Callback = function(Text)
        if Text == "" then return end

        local ok, parsed = pcall(function() return HttpService:JSONDecode(Text) end)
        if not ok or type(parsed) ~= "table" then
            Rayfield:Notify({
                Title = "Import Failed",
                Content = "Invalid JSON format!",
                Duration = 3,
                Image = 4483362458,
            })
            return
        end

        local defaultName = "Imported_" .. os.time()
        saveReplay(defaultName, parsed)

        -- Refresh the dropdown
        local names = getReplayNames()
        ReplayDropdown:Refresh(names, true)

        Rayfield:Notify({
            Title = "Import Successful",
            Content = "Replay imported as: " .. defaultName,
            Duration = 3,
            Image = 4483362458,
        })
    end,
})

-- Main game loop
RunService.RenderStepped:Connect(function()
    -- Auto-start replay on first note
    if startReplayOnNote and selectedReplayName and not isReplaying then
        for _, note in ipairs(notesContainer:GetChildren()) do
            if note and (note:IsA("ImageLabel") or note:IsA("Frame")) then
                local y = note.Position.Y.Scale
                if y >= (hitLineTap - window) then
                    playReplayByName(selectedReplayName)
                    startReplayOnNote = false
                    AutoStartReplayToggle:Set(false)
                    break
                end
            end
        end
    end

    if not autoplay then return end
    local keysToPress = {}

    for _, lane in ipairs(lanes) do
        local toTap, holdPresent = false, false
        for _, note in ipairs(notesContainer:GetChildren()) do
            if note and (note:IsA("ImageLabel") or note:IsA("Frame")) then
                local x = note.Position.X.Scale
                local y = note.Position.Y.Scale
                if math.abs(x - lane.pos) <= window then
                    if note:IsA("Frame") then
                        if y >= (hitLineHold - window) then holdPresent = true end
                    else
                        local missRoll = (math.random() * 100) < missChancePercent
                        if y >= (hitLineTap - window) and not missRoll then
                            toTap = true
                            pcall(function() note:Destroy() end)
                        end
                    end
                end
            end
        end

        -- Hold note logic
        if holdPresent and not lane.held and not lane.pending then
            lane.pending = task.spawn(function()
                task.wait(0)
                if holdExistsInLane(lane) then
                    lane.held = true
                    keyDown(lane.key)
                    recordEvent({ t = tick() - recordStartTick, type = "down", key = lane.key.Name })
                end
                lane.pending = nil
            end)
        elseif not holdPresent then
            if lane.pending then lane.pending = nil end
            if lane.held then
                lane.held = false
                keyUp(lane.key)
                recordEvent({ t = tick() - recordStartTick, type = "up", key = lane.key.Name })
            end
        end

        if toTap then table.insert(keysToPress, lane.key) end
    end

    -- Process tap notes
    if #keysToPress > 0 then
        if recordOnFirstAuto and not isRecording then
            isRecording = true
            recordEvents = {}
            recordStartTick = tick()
            recordOnFirstAuto = false
            Rayfield:Notify({
                Title = "Auto-Recording Started",
                Content = "Recording began with first autoplay!",
                Duration = 2,
                Image = 4483362458,
            })
        end

        local timingOffset = (math.random() * 2 - 1) * timingOffsetMax
        local holdTime = math.random() * (holdMax - holdMin) + holdMin

        task.spawn(function()
            if timingOffset > 0 then task.wait(timingOffset) end
            for _,k in ipairs(keysToPress) do recordEvent({ t = tick() - recordStartTick, type = "down", key = k.Name }) end
            pressMultipleKeys(keysToPress, holdTime)
            for _,k in ipairs(keysToPress) do recordEvent({ t = tick() - recordStartTick, type = "up", key = k.Name }) end
        end)
        firstAutoPressOccurred = true
    end
end)

-- Initial load: try to read local files into memory and refresh dropdown
task.spawn(function()
    task.wait(1) -- Wait for UI to load

    -- Load local files into replays table
    if has_listfiles and has_readfile then
        local localNames = listLocalReplayFiles()
        for _, name in ipairs(localNames) do
            local ok, content = pcall(function() return readLocalReplayFile(name) end)
            if ok and content then
                replays[name] = content
            end
        end
    end

    -- Refresh the dropdown now that replays are loaded
    local names = getReplayNames()
    if ReplayDropdown and ReplayDropdown.Refresh then
        ReplayDropdown:Refresh(names, true)
    end
end)
