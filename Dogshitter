local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local VIM = game:GetService("VirtualInputManager") -- like vim the text editor
local HttpService = game:GetService("HttpService")
local UserInputService = game:GetService("UserInputService")
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

local notesContainer = playerGui
    :WaitForChild("ScreenGui")
    :WaitForChild("GAMEFRAME")
    :WaitForChild("YOU")
    :WaitForChild("NotesContainer") -- i forgot how to so chatgpt gave this fucking family tree

-- runrunrun
local hitLineTap = 0.85
local hitLineHold = 0.85

local lanes = {
    { pos = 0.197892383, key = Enum.KeyCode.S, held = false, pending = nil }, -- 1
    { pos = 0.401, key = Enum.KeyCode.D, held = false, pending = nil }, -- 2
    { pos = 0.602, key = Enum.KeyCode.K, held = false, pending = nil }, -- 3
    { pos = 0.800066233, key = Enum.KeyCode.L, held = false, pending = nil }  -- 4
}

--defaults
local windowMinDefault, windowMaxDefault = 0.01, 0.03
local holdMinDefault, holdMaxDefault = 0.05, 0.15
local timingOffsetMaxDefault = 0.02

local autoplay = false
local window = (windowMinDefault + windowMaxDefault) / 2
local holdMin, holdMax = holdMinDefault, holdMaxDefault
local missChancePercent = 0 -- broken
local timingOffsetMax = timingOffsetMaxDefault

-- recording
local isRecording = false
local recordEvents = {}
local recordStartTick = 0

local replaysFolder = workspace:FindFirstChild("Sigmareplays")
if not replaysFolder then
    replaysFolder = Instance.new("Folder")
    replaysFolder.Name = "Sigmareplays" -- sigma
    replaysFolder.Parent = workspace
end

local isReplaying = false
local currentReplayTask = nil
local selectedReplayName = nil

local recordOnFirstAuto = false
local startReplayOnNote = false
local firstAutoPressOccurred = false

--vim help
local function keyDown(key) pcall(function() VIM:SendKeyEvent(true, key, false, game) end) end
local function keyUp(key)   pcall(function() VIM:SendKeyEvent(false, key, false, game) end) end
local function pressMultipleKeys(keys, holdTime)
    for _,k in ipairs(keys) do keyDown(k) end
    task.wait(holdTime)
    for _,k in ipairs(keys) do keyUp(k) end
end

--ui help
local function create(parent, class, props)
    local obj = Instance.new(class)
    if props then for k,v in pairs(props) do obj[k] = v end end
    obj.Parent = parent
    return obj
end

local function makeSlider(parent, labelText, min, max, initial, yPos)
    local container = create(parent, "Frame", {
        Size = UDim2.new(0, 280, 0, 36),
        Position = UDim2.new(0, 8, 0, yPos or 0),
        BackgroundTransparency = 1
    })
    create(container, "TextLabel", {
        Size = UDim2.new(0.62, 0, 1, 0),
        Position = UDim2.new(0, 0, 0, 0),
        BackgroundTransparency = 1,
        Text = labelText,
        TextXAlignment = Enum.TextXAlignment.Left,
        Font = Enum.Font.Gotham,
        TextSize = 12,
        TextColor3 = Color3.new(1,1,1)
    })
    local valueLabel = create(container, "TextLabel", {
        Size = UDim2.new(0.38, 0, 1, 0),
        Position = UDim2.new(0.62, 0, 0, 0),
        BackgroundTransparency = 1,
        Text = tostring(initial),
        TextXAlignment = Enum.TextXAlignment.Right,
        Font = Enum.Font.Gotham,
        TextSize = 12,
        TextColor3 = Color3.new(1,1,1)
    })
    local bar = create(container, "Frame", {
        Size = UDim2.new(1, 0, 0, 6),
        Position = UDim2.new(0, 0, 1, -10),
        BackgroundColor3 = Color3.fromRGB(60,60,60),
    })
    create(bar, "UICorner", { CornerRadius = UDim.new(0,4) })
    local knob = create(bar, "Frame", {
        Size = UDim2.new(0, 12, 1, 0),
        Position = UDim2.new(0, 0, 0, 0),
        BackgroundColor3 = Color3.fromRGB(200,200,200)
    })
    create(knob, "UICorner", { CornerRadius = UDim.new(0,6) })

    local function setFromInput(inputX)
        local abs = bar.AbsolutePosition.X
        local width = bar.AbsoluteSize.X
        if width <= 0 then return end
        local localX = math.clamp(inputX - abs, 0, width)
        local newPct = localX / width
        knob.Position = UDim2.new(newPct, -6, 0, 0)
        local value = min + (max - min) * newPct
        valueLabel.Text = string.format("%.4f", value)
        bar:SetAttribute("sliderValue", value)
        return value
    end

    local dragging = false
    knob.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then dragging = true end
    end)
    knob.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then dragging = false end
    end)
    bar.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
            setFromInput(input.Position.X)
        end
    end)
    UserInputService.InputChanged:Connect(function(input)
        if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
            setFromInput(input.Position.X)
        end
    end)

    local function getValue()
        local v = bar:GetAttribute("sliderValue")
        if v then return math.clamp(v, min, max) end
        return tonumber(valueLabel.Text) or initial
    end
    local function setValue(v)
        v = math.clamp(v, min, max)
        valueLabel.Text = string.format("%.4f", v)
        local pct2 = (v - min) / (max - min)
        knob.Position = UDim2.new(pct2, -6, 0, 0)
        bar:SetAttribute("sliderValue", v)
    end

    setValue(initial)
    return { getValue = getValue, setValue = setValue, container = container, valueLabel = valueLabel }
end

local screenGui = create(playerGui, "ScreenGui", { Name = "Autoplay", ResetOnSpawn = false })
local main = create(screenGui, "Frame", {
    Size = UDim2.new(0, 480, 0, 420),
    Position = UDim2.new(0.02, 0, 0.12, 0),
    BackgroundColor3 = Color3.fromRGB(28,28,28)
})
create(main, "UICorner", { CornerRadius = UDim.new(0,6) })
local titleBar = create(main, "Frame", {
    Size = UDim2.new(1, 0, 0, 34),
    Position = UDim2.new(0,0,0,0),
    BackgroundTransparency = 1
})
create(titleBar, "TextLabel", {
    Size = UDim2.new(1,0,1,0),
    BackgroundTransparency = 1,
    Text = "DogshitterV0.11",
    Font = Enum.Font.GothamBold,
    TextSize = 16,
    TextColor3 = Color3.new(1,1,1)
})

do
    local dragging = false
    local dragStart = nil
    local startPos = nil
    titleBar.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
            dragStart = input.Position
            startPos = main.Position
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)
    titleBar.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement and dragging then
            local delta = input.Position - dragStart
            main.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
        end
    end)
end

local btnArea = create(main, "Frame", { Size = UDim2.new(0, 480, 0, 40), Position = UDim2.new(0, 8, 0, 42), BackgroundTransparency = 1 })
local btnAuto = create(btnArea, "TextButton", { Size = UDim2.new(0, 120, 1, 0), Position = UDim2.new(0,0,0,0), Text = "Autoplay: OFF", Font = Enum.Font.GothamSemibold, TextSize = 11 })
local btnAutoRec = create(btnArea, "TextButton", { Size = UDim2.new(0, 120, 1, 0), Position = UDim2.new(0, 125, 0, 0), Text = "Auto+Rec: OFF", Font = Enum.Font.GothamSemibold, TextSize = 11 })
local btnKill = create(btnArea, "TextButton", { Size = UDim2.new(0, 214, 1, 0), Position = UDim2.new(0, 250, 0, 0), Text = "Kill", Font = Enum.Font.Gotham, TextSize = 11 })

--sleider
local sWindow = makeSlider(main, "Hit window center", 0.000, 0.1, (windowMinDefault + windowMaxDefault)/2, 100)
local sHold   = makeSlider(main, "Tap hold time", 0.00, 0.3, (holdMinDefault + holdMaxDefault)/2, 148)
local sMiss   = makeSlider(main, "Miss chance", 0, 99, 0, 196)
local sTiming = makeSlider(main, "Max timing offset", 0, 0.1, timingOffsetMaxDefault, 244)

local replayFrame = create(main, "Frame", {
    Size = UDim2.new(0, 180, 0, 260),
    Position = UDim2.new(0, 292, 0, 86),
    BackgroundColor3 = Color3.fromRGB(36,36,36)
})
create(replayFrame, "UICorner", { CornerRadius = UDim.new(0,6) })
create(replayFrame, "TextLabel", { Size = UDim2.new(1, -12, 0, 18), Position = UDim2.new(0, 6, 0, 6), BackgroundTransparency = 1, Text = "Replays", Font = Enum.Font.GothamBold, TextSize = 12, TextColor3 = Color3.new(1,1,1), TextXAlignment = Enum.TextXAlignment.Left })

local replayList = create(replayFrame, "ScrollingFrame", {
    Size = UDim2.new(1, -12, 1, -30),
    Position = UDim2.new(0,6,0,30),
    CanvasSize = UDim2.new(0,0,0,0),
    ScrollBarThickness = 6,
    BackgroundTransparency = 1
})
local replayLayout = create(replayList, "UIListLayout", { Padding = UDim.new(0,4) })

local btnRefreshReplays = create(replayFrame, "TextButton", { Size = UDim2.new(1, -12, 0, 20), Position = UDim2.new(0,6,1,-26), Text = "Refresh", Font = Enum.Font.Gotham, TextSize = 11 })

local exportBtn = create(main, "TextButton", { Size = UDim2.new(0, 80, 0, 24), Position = UDim2.new(0, 10, 0, 320), Text = "Show JSON", Font = Enum.Font.Gotham, TextSize = 11 })
local importBox = create(main, "TextBox", { Size = UDim2.new(0, 140, 0, 24), Position = UDim2.new(0, 95, 0, 320), Text = "", Font = Enum.Font.Gotham, TextSize = 11, ClearTextOnFocus = false })
local importBtn = create(main, "TextButton", { Size = UDim2.new(0, 50, 0, 24), Position = UDim2.new(0, 240, 0, 320), Text = "Import", Font = Enum.Font.Gotham, TextSize = 11 })

local btnRecord = create(main, "TextButton", { Size = UDim2.new(0, 85, 0, 24), Position = UDim2.new(0, 10, 0, 350), Text = "Start Rec", Font = Enum.Font.Gotham, TextSize = 11 })
local btnStopRec = create(main, "TextButton", { Size = UDim2.new(0, 75, 0, 24), Position = UDim2.new(0, 100, 0, 350), Text = "Stop Rec", Font = Enum.Font.Gotham, TextSize = 11 })
local btnStartReplay = create(main, "TextButton", { Size = UDim2.new(0, 85, 0, 24), Position = UDim2.new(0, 180, 0, 350), Text = "Start Replay", Font = Enum.Font.Gotham, TextSize = 11 })
local btnStopReplay = create(main, "TextButton", { Size = UDim2.new(0, 201, 0, 24), Position = UDim2.new(0, 270, 0, 350), Text = "Stop Replay", Font = Enum.Font.Gotham, TextSize = 11 })

local startReplayOnNoteBtn = create(main, "TextButton", { Size = UDim2.new(0, 461, 0, 22), Position = UDim2.new(0, 10, 0, 378), Text = "Start replay automatically on first note: OFF", Font = Enum.Font.Gotham, TextSize = 11 })

local function refreshReplayList()
    for _,c in ipairs(replayList:GetChildren()) do
        if not c:IsA("UIListLayout") then c:Destroy() end
    end
    local names = {}
    for _,v in ipairs(replaysFolder:GetChildren()) do
        if v:IsA("StringValue") then table.insert(names, v.Name) end
    end
    table.sort(names)
    for i,name in ipairs(names) do
        local btn = create(replayList, "TextButton", {
            Size = UDim2.new(1, 0, 0, 24),
            Text = name,
            Font = Enum.Font.Gotham,
            TextSize = 12,
            BackgroundColor3 = Color3.fromRGB(48,48,48),
            TextColor3 = Color3.new(1,1,1)
        })
        btn.MouseButton1Click:Connect(function()
            selectedReplayName = name
            for _,child in ipairs(replayList:GetChildren()) do
                if child:IsA("TextButton") then child.BackgroundColor3 = Color3.fromRGB(48,48,48) end
            end
            btn.BackgroundColor3 = Color3.fromRGB(80,120,200)
        end)
        if i == #names then
            selectedReplayName = name
            btn.BackgroundColor3 = Color3.fromRGB(80,120,200)
        end
    end
    local layout = replayList:FindFirstChildOfClass("UIListLayout")
    if layout then
        replayList.CanvasSize = UDim2.new(0,0,0, layout.AbsoluteContentSize.Y + 8)
    end
end
refreshReplayList()

--save
local function saveReplay(name, events)
    if not name or name == "" then name = "Replay_"..os.time() end
    local json = HttpService:JSONEncode(events)
    local existing = replaysFolder:FindFirstChild(name)
    if existing and existing:IsA("StringValue") then
        existing.Value = json
    else
        local sv = Instance.new("StringValue")
        sv.Name = name
        sv.Value = json
        sv.Parent = replaysFolder
    end
    refreshReplayList()
end

--cry
local function playReplayByName(name)
    if isReplaying then return end
    local item = replaysFolder:FindFirstChild(name)
    if not item or not item:IsA("StringValue") then return end
    local ok, events = pcall(function() return HttpService:JSONDecode(item.Value) end)
    if not ok or type(events) ~= "table" then return end

    isReplaying = true
    currentReplayTask = task.spawn(function()
        local startTime = tick()
        for _,ev in ipairs(events) do
            if not isReplaying then break end
            local target = startTime + ev.t
            local now = tick()
            if target > now then task.wait(target - now) end
            if not isReplaying then break end
            local keyCode = nil
            for _,l in ipairs(lanes) do
                if l.key.Name == ev.key then keyCode = l.key end
            end
            if keyCode then
                if ev.type == "down" then keyDown(keyCode) elseif ev.type == "up" then keyUp(keyCode) end
            end
        end
        isReplaying = false
    end)
end

--logitech
btnAuto.MouseButton1Click:Connect(function()
    autoplay = not autoplay
    btnAuto.Text = autoplay and "Autoplay: ON" or "Autoplay: OFF"
    if autoplay then firstAutoPressOccurred = false end
    if not autoplay then
        for _,l in ipairs(lanes) do
            if l.held then keyUp(l.key); l.held = false end
            l.pending = nil
        end
    end
end)

local autoRecActive = false
btnAutoRec.MouseButton1Click:Connect(function()
    autoRecActive = not autoRecActive
    if autoRecActive then
        autoplay = true
        recordOnFirstAuto = true
        btnAuto.Text = "Autoplay: ON"
        btnAutoRec.Text = "Auto+Rec: ON"
        firstAutoPressOccurred = false
    else
        autoplay = false
        recordOnFirstAuto = false
        btnAuto.Text = "Autoplay: OFF"
        btnAutoRec.Text = "Auto+Rec: OFF"
        for _,l in ipairs(lanes) do
            if l.held then keyUp(l.key); l.held = false end
            l.pending = nil
        end
    end
end)

btnKill.MouseButton1Click:Connect(function() screenGui:Destroy() end)

btnRecord.MouseButton1Click:Connect(function()
    if isRecording then return end
    isRecording = true
    recordEvents = {}
    recordStartTick = tick()
    btnRecord.Text = "Rec: ON"
end)

btnStopRec.MouseButton1Click:Connect(function()
    if not isRecording then return end
    isRecording = false
    btnRecord.Text = "Start Rec"
    local namePrompt = create(screenGui, "Frame", {
        Size = UDim2.new(0, 320, 0, 120),
        Position = UDim2.new(0.5, -160, 0.5, -60),
        BackgroundColor3 = Color3.fromRGB(40,40,40)
    })
    create(namePrompt, "UICorner", { CornerRadius = UDim.new(0,6) })
    create(namePrompt, "TextLabel", {
        Size = UDim2.new(1, -20, 0, 28),
        Position = UDim2.new(0, 10, 0, 8),
        BackgroundTransparency = 1,
        Text = "Name this replay:",
        Font = Enum.Font.Gotham,
        TextSize = 16,
        TextColor3 = Color3.fromRGB(255,255,255)
    })
    local input = create(namePrompt, "TextBox", {
        Size = UDim2.new(1, -20, 0, 30),
        Position = UDim2.new(0, 10, 0, 42),
        Text = "Replay_"..os.time(),
        Font = Enum.Font.Gotham,
        TextSize = 14
    })
    local btnSave = create(namePrompt, "TextButton", { Size = UDim2.new(0, 120, 0, 28), Position = UDim2.new(0.5, -60, 1, -36), Text = "Save" })
    local btnCancel = create(namePrompt, "TextButton", { Size = UDim2.new(0, 80, 0, 28), Position = UDim2.new(0.5, 66, 1, -36), Text = "Cancel" })

    btnSave.MouseButton1Click:Connect(function()
        local name = tostring(input.Text):gsub("[%c%/%\\%:%%%*%?%\"%<%>%|]", "_")
        saveReplay(name, recordEvents)
        namePrompt:Destroy()
    end)
    btnCancel.MouseButton1Click:Connect(function() namePrompt:Destroy() end)
end)

btnRefreshReplays.MouseButton1Click:Connect(refreshReplayList)

btnStartReplay.MouseButton1Click:Connect(function()
    if not selectedReplayName then return end
    playReplayByName(selectedReplayName)
end)
btnStopReplay.MouseButton1Click:Connect(function()
    isReplaying = false
    currentReplayTask = nil
end)

startReplayOnNoteBtn.MouseButton1Click:Connect(function()
    startReplayOnNote = not startReplayOnNote
    startReplayOnNoteBtn.Text = "Start replay automatically on first note: " .. (startReplayOnNote and "ON" or "OFF")
end)

-- export popup
exportBtn.MouseButton1Click:Connect(function()
    if not selectedReplayName then return end
    local item = replaysFolder:FindFirstChild(selectedReplayName)
    if not item then return end
    local json = item.Value or ""
    local popup = create(screenGui, "Frame", {
        Size = UDim2.new(0, 560, 0, 300),
        Position = UDim2.new(0.5, -280, 0.5, -150),
        BackgroundColor3 = Color3.fromRGB(30,30,30)
    })
    create(popup, "UICorner", { CornerRadius = UDim.new(0,6) })
    create(popup, "TextLabel", { Size = UDim2.new(1, -20, 0, 28), Position = UDim2.new(0,10,0,8), BackgroundTransparency = 1,
        Text = "blehhh:", Font = Enum.Font.Gotham, TextSize = 16, TextColor3 = Color3.new(1,1,1) })
    local box = create(popup, "TextBox", { Size = UDim2.new(1, -20, 1, -80), Position = UDim2.new(0,10,0,40), Text = json, ClearTextOnFocus = false, MultiLine = true, Font = Enum.Font.Gotham, TextSize = 12 })
    local btnClose = create(popup, "TextButton", { Size = UDim2.new(0, 80, 0, 28), Position = UDim2.new(1, -90, 1, -36), Text = "Close" })
    btnClose.MouseButton1Click:Connect(function() popup:Destroy() end)
    box:CaptureFocus()
end)

-- import
importBtn.MouseButton1Click:Connect(function()
    local text = tostring(importBox.Text or ""):gsub("^%s+", ""):gsub("%s+$", "")
    if text == "" then return end
    local ok, parsed = pcall(function() return HttpService:JSONDecode(text) end)
    if not ok or type(parsed) ~= "table" then
        local p = create(screenGui, "TextLabel", { Size = UDim2.new(0, 260, 0, 36), Position = UDim2.new(0.5, -130, 0.5, -20), BackgroundColor3 = Color3.fromRGB(180,60,60), Text = "Invalid JSON", TextColor3 = Color3.new(1,1,1), Font = Enum.Font.Gotham })
        task.delay(1.2, function() p:Destroy() end)
        return
    end
    local defaultName = "Imported_"..os.time()
    saveReplay(defaultName, parsed)
    importBox.Text = ""
end)

local function recordEvent(ev)
    if not isRecording then return end
    table.insert(recordEvents, ev)
end

local function holdExistsInLane(lane)
    for _, note in ipairs(notesContainer:GetChildren()) do
        if note and note:IsA("Frame") then
            local x = note.Position.X.Scale
            local y = note.Position.Y.Scale
            if math.abs(x - lane.pos) <= window and y >= (hitLineHold - window) then
                return true
            end
        end
    end
    return false
end

RunService.RenderStepped:Connect(function()
    local sValWindow = sWindow.getValue()
    local sValHold = sHold.getValue()
    local sValMiss = sMiss.getValue()
    local sValTiming = sTiming.getValue()

    window = math.clamp(sValWindow, 0.001, 0.2)
    holdMin = math.clamp(sValHold - 0.02, 0.01, 1)
    holdMax = math.clamp(sValHold + 0.02, 0.01, 2)
    missChancePercent = math.clamp(sValMiss, 0, 100)
    timingOffsetMax = math.clamp(sValTiming, 0, 0.2)

--
    if startReplayOnNote and selectedReplayName and not isReplaying then
        for _, note in ipairs(notesContainer:GetChildren()) do
            if note and (note:IsA("ImageLabel") or note:IsA("Frame")) then
                local y = note.Position.Y.Scale
                if y >= (hitLineTap - window) then
                    playReplayByName(selectedReplayName)
                    startReplayOnNote = false
                    startReplayOnNoteBtn.Text = "Start selected replay on note: OFF"
                    break
                end
            end
        end
    end

    if not autoplay then return end
    local keysToPress = {}

    for _, lane in ipairs(lanes) do
        local toTap, holdPresent = false, false
        for _, note in ipairs(notesContainer:GetChildren()) do
            if note and (note:IsA("ImageLabel") or note:IsA("Frame")) then
                local x = note.Position.X.Scale
                local y = note.Position.Y.Scale
                if math.abs(x - lane.pos) <= window then
                    if note:IsA("Frame") then
                        if y >= (hitLineHold - window) then holdPresent = true end
                    else
                        local missRoll = (math.random() * 100) < missChancePercent
                        if y >= (hitLineTap - window) and not missRoll then
                            toTap = true
                            pcall(function() note:Destroy() end)
                        end
                    end
                end
            end
        end






























        if holdPresent and not lane.held and not lane.pending then
            lane.pending = task.spawn(function()
                task.wait(0.1)
                if holdExistsInLane(lane) then
                    lane.held = true
                    keyDown(lane.key)
                    recordEvent({ t = tick() - recordStartTick, type = "down", key = lane.key.Name })
                end
                lane.pending = nil
            end)
        elseif not holdPresent then
            if lane.pending then lane.pending = nil end
            if lane.held then
                lane.held = false
                keyUp(lane.key)
                recordEvent({ t = tick() - recordStartTick, type = "up", key = lane.key.Name })
            end
        end

        if toTap then table.insert(keysToPress, lane.key) end
    end

    if #keysToPress > 0 then
        if recordOnFirstAuto and not isRecording then
            isRecording = true
            recordEvents = {}
            recordStartTick = tick()
            btnRecord.Text = "Rec: ON"
            recordOnFirstAuto = false
        end
        local timingOffset = (math.random() * 2 - 1) * timingOffsetMax
        local holdTime = math.random() * (holdMax - holdMin) + holdMin
        task.spawn(function()
            if timingOffset > 0 then task.wait(timingOffset) end
            for _,k in ipairs(keysToPress) do recordEvent({ t = tick() - recordStartTick, type = "down", key = k.Name }) end
            pressMultipleKeys(keysToPress, holdTime)
            for _,k in ipairs(keysToPress) do recordEvent({ t = tick() - recordStartTick, type = "up", key = k.Name }) end
        end)
        firstAutoPressOccurred = true
    end
end)
refreshReplayList()
